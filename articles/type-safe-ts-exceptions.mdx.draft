---
  title: 'Type Safe Typescript Exceptions'
  tags: ['typescript', 'exceptions', 'monads']
---
# Type Safe Typescript Exceptions
Frequently, I've wished that I could reason about
exceptions in a type safe manner.
But in Typescript, exceptions have `any` type by default.
You can throw whatever but when you catch it, it will have `any` type.


The alternative to using exceptions is to use discriminated unions
to indicate the possibility of an error. Something like this.

```
type MyResult<T> =
  { isError: true, error: ErrorType} |
  { isError: false, value: T }
```

This will force the user of a `MyResult<T>` value to check the 
`isError` field on the result to access the value field.
However, this approach, while type safe, has a lot of boilerplate
for the common case of error propagation. Just like Go.

If you had used exceptions, you could have called
them like normal functions and the errors thrown
by each inner function would have propagated up,
essentially "short circuiting" the evaluation if
any step failed.


## The pitch
We discuss a way to create a nicer syntax for type
checked error handling, kind of like `async/await`,
but for your own types.

## The short version

This is the signature of the function we need.
```typescript
function failable<T, E = never>(
  f: (
    (arg: {
      success(value: T): Failable<T, E>;
      failure(error: E): Failable<T, E>;
      run<R>(func: () => Failable<R, E>): R;
    }) => Failable<T, E>
  )
): Failable<T, E>
```

This is the syntax that this function will enable.

```typescript

type GetUserError = GetUserRowError | ParseUserError
const getUser = (userId: string): Failable<User, GetUserError> => failable(f => {
    const row = f.rethrow(getUserRow(userId))
    const user = f.rethrow(parseUser(row))

    return f.success(user)
})
```






